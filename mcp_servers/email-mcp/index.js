/**
 * Email MCP Server - Silver Tier
 * ===============================
 * Draft and send emails via Gmail API with HITL approval workflow.
 * 
 * Capabilities:
 * - draft_email: Save draft as .md in /Plans/email_draft_[date].md
 * - send_email: Send email only after HITL approval
 * - list_drafts: List all email drafts
 * - approve_draft: Move draft from Pending_Approval to Approved
 * 
 * Run: node mcp_servers/email-mcp/index.js
 * Test: See test.js for usage examples
 */

const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
const {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} = require('@modelcontextprotocol/sdk/types.js');
const { google } = require('googleapis');
const fs = require('fs');
const path = require('path');
const { fileURLToPath } = require('url');

// Configuration
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = path.resolve(__dirname, '../..');
const PLANS_DIR = path.join(PROJECT_ROOT, 'Plans');
const PENDING_APPROVAL_DIR = path.join(PROJECT_ROOT, 'Pending_Approval');
const APPROVED_DIR = path.join(PROJECT_ROOT, 'Approved');
const CREDENTIALS_FILE = path.join(PROJECT_ROOT, 'credentials.json');
const TOKEN_FILE = path.join(PROJECT_ROOT, 'token.json');

// Ensure directories exist
[PLANS_DIR, PENDING_APPROVAL_DIR, APPROVED_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Gmail API Configuration
const SCOPES = ['https://www.googleapis.com/auth/gmail.send', 'https://www.googleapis.com/auth/gmail.drafts'];

/**
 * Authenticate with Gmail API
 */
async function authenticateGmail() {
  if (!fs.existsSync(CREDENTIALS_FILE)) {
    throw new Error(`credentials.json not found at ${CREDENTIALS_FILE}. Download from Google Cloud Console.`);
  }

  let creds = null;
  
  if (fs.existsSync(TOKEN_FILE)) {
    const tokenData = JSON.parse(fs.readFileSync(TOKEN_FILE, 'utf-8'));
    creds = new google.auth.OAuth2({
      clientId: tokenData.client_id,
      clientSecret: tokenData.client_secret,
      refreshToken: tokenData.refresh_token,
    });
    creds.setCredentials({
      access_token: tokenData.access_token,
      refresh_token: tokenData.refresh_token,
      expiry_date: tokenData.expiry_date,
    });
  }

  if (!creds || !creds.credentials?.refresh_token) {
    // Interactive auth needed
    const auth = new google.auth.OAuth2(
      'YOUR_CLIENT_ID',
      'YOUR_CLIENT_SECRET',
      'http://localhost:3000/oauth2callback'
    );
    const authUrl = auth.generateAuthUrl({
      access_type: 'offline',
      scope: SCOPES,
    });
    throw new Error(`Please authenticate at: ${authUrl}`);
  }

  return google.gmail({ version: 'v1', auth: creds });
}

/**
 * Create email draft as markdown file
 */
function createEmailDraft(to, subject, body, cc = '', bcc = '') {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const filename = `email_draft_${timestamp}.md`;
  const filepath = path.join(PLANS_DIR, filename);

  const content = `---
type: email_draft
to: ${to}
cc: ${cc}
bcc: ${bcc}
subject: ${subject}
created: ${new Date().toISOString()}
status: draft
priority: normal
---

# Email Draft

## Recipients
- **To:** ${to}
${cc ? `- **CC:** ${cc}` : ''}
${bcc ? `- **BCC:** ${bcc}` : ''}

## Subject
${subject}

## Body

${body}

---
*Status: draft - Requires HITL approval before sending*
*Generated by Email MCP Server - Silver Tier*

## Actions
- To approve: Move to /Approved/ and use send_email tool
- To reject: Move to /Rejected/
- To edit: Modify this file and resubmit
`;

  fs.writeFileSync(filepath, content, 'utf-8');
  
  return {
    filepath,
    filename,
    status: 'draft',
    message: `Email draft created: ${filename}`
  };
}

/**
 * Send email via Gmail API
 */
async function sendEmail(to, subject, body, cc = '', bcc = '') {
  const gmail = await authenticateGmail();

  const message = [
    `From: me`,
    `To: ${to}`,
    cc ? `Cc: ${cc}` : '',
    `Subject: ${subject}`,
    'MIME-Version: 1.0',
    'Content-Type: text/plain; charset=utf-8',
    '',
    body
  ].filter(line => line).join('\r\n');

  const encodedMessage = Buffer.from(message)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');

  const response = await gmail.users.messages.send({
    userId: 'me',
    requestBody: {
      raw: encodedMessage
    }
  });

  return {
    messageId: response.data.id,
    threadId: response.data.threadId,
    status: 'sent',
    message: `Email sent successfully to ${to}`
  };
}

/**
 * List all email drafts
 */
function listDrafts() {
  const drafts = [];
  
  if (fs.existsSync(PLANS_DIR)) {
    const files = fs.readdirSync(PLANS_DIR);
    for (const file of files) {
      if (file.startsWith('email_draft_') && file.endsWith('.md')) {
        const filepath = path.join(PLANS_DIR, file);
        const content = fs.readFileSync(filepath, 'utf-8');
        
        // Extract metadata
        const toMatch = content.match(/to:\s*(.+)/i);
        const subjectMatch = content.match(/subject:\s*(.+)/i);
        const statusMatch = content.match(/status:\s*(.+)/i);
        const createdMatch = content.match(/created:\s*(.+)/i);
        
        drafts.push({
          filename: file,
          to: toMatch ? toMatch[1].trim() : 'Unknown',
          subject: subjectMatch ? subjectMatch[1].trim() : 'No Subject',
          status: statusMatch ? statusMatch[1].trim() : 'unknown',
          created: createdMatch ? createdMatch[1].trim() : 'Unknown'
        });
      }
    }
  }

  return drafts;
}

/**
 * Approve draft for sending
 */
function approveDraft(filename) {
  const sourcePath = path.join(PENDING_APPROVAL_DIR, filename);
  const destPath = path.join(APPROVED_DIR, filename);

  if (!fs.existsSync(sourcePath)) {
    // Try Plans directory
    const plansPath = path.join(PLANS_DIR, filename);
    if (fs.existsSync(plansPath)) {
      fs.copyFileSync(plansPath, destPath);
      return {
        status: 'approved',
        message: `Draft approved: ${filename}`,
        filepath: destPath
      };
    }
    throw new Error(`Draft not found: ${filename}`);
  }

  fs.copyFileSync(sourcePath, destPath);
  
  return {
    status: 'approved',
    message: `Draft approved: ${filename}`,
    filepath: destPath
  };
}

// MCP Server Setup
const server = new Server(
  {
    name: 'email-mcp-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// List available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'draft_email',
        description: 'Create an email draft saved as markdown in /Plans/. Requires HITL approval before sending.',
        inputSchema: {
          type: 'object',
          properties: {
            to: {
              type: 'string',
              description: 'Recipient email address'
            },
            subject: {
              type: 'string',
              description: 'Email subject line'
            },
            body: {
              type: 'string',
              description: 'Email body content'
            },
            cc: {
              type: 'string',
              description: 'CC recipients (optional)',
              default: ''
            },
            bcc: {
              type: 'string',
              description: 'BCC recipients (optional)',
              default: ''
            }
          },
          required: ['to', 'subject', 'body']
        }
      },
      {
        name: 'send_email',
        description: 'Send an email via Gmail API. Use only after HITL approval.',
        inputSchema: {
          type: 'object',
          properties: {
            to: {
              type: 'string',
              description: 'Recipient email address'
            },
            subject: {
              type: 'string',
              description: 'Email subject line'
            },
            body: {
              type: 'string',
              description: 'Email body content'
            },
            cc: {
              type: 'string',
              description: 'CC recipients (optional)',
              default: ''
            },
            bcc: {
              type: 'string',
              description: 'BCC recipients (optional)',
              default: ''
            },
            draft_file: {
              type: 'string',
              description: 'Optional: Path to approved draft file'
            }
          },
          required: ['to', 'subject', 'body']
        }
      },
      {
        name: 'list_drafts',
        description: 'List all email drafts in /Plans/ directory',
        inputSchema: {
          type: 'object',
          properties: {}
        }
      },
      {
        name: 'approve_draft',
        description: 'Approve an email draft for sending (HITL workflow)',
        inputSchema: {
          type: 'object',
          properties: {
            filename: {
              type: 'string',
              description: 'Name of the draft file to approve'
            }
          },
          required: ['filename']
        }
      }
    ]
  };
});

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'draft_email': {
        const result = createEmailDraft(
          args.to,
          args.subject,
          args.body,
          args.cc || '',
          args.bcc || ''
        );
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }

      case 'send_email': {
        const result = await sendEmail(
          args.to,
          args.subject,
          args.body,
          args.cc || '',
          args.bcc || ''
        );
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }

      case 'list_drafts': {
        const drafts = listDrafts();
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({ drafts }, null, 2)
            }
          ]
        };
      }

      case 'approve_draft': {
        const result = approveDraft(args.filename);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ error: error.message }, null, 2)
        }
      ],
      isError: true
    };
  }
});

// Start server
async function main() {
  console.error('Email MCP Server starting...');
  console.error(`Project Root: ${PROJECT_ROOT}`);
  console.error(`Plans Dir: ${PLANS_DIR}`);
  console.error(`Pending Approval Dir: ${PENDING_APPROVAL_DIR}`);
  console.error(`Approved Dir: ${APPROVED_DIR}`);
  console.error('');
  console.error('Available tools:');
  console.error('  - draft_email: Create email draft');
  console.error('  - send_email: Send email (requires approval)');
  console.error('  - list_drafts: List all drafts');
  console.error('  - approve_draft: Approve draft for sending');
  console.error('');

  const transport = new StdioServerTransport();
  await server.connect(transport);
  
  console.error('Email MCP Server running on stdio');
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
